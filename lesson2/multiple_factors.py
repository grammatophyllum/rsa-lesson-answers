from Crypto.Util.number import inverse, long_to_bytes
from factordb.factordb import FactorDB

c = 440491186409221577222937849683689384921646492847864076225999714628443725912310988162641138821652909092383256898564809008224699209053648398143021994605495151641895069816456468875592212286821082915592131699673749976051145385639044623700201635158386163179217974177078372437536132859271180074759994649844436056289042939122084236627334871469651240
n = 2288270088846735357106859785057471410964029178751275985133437188112869387065357149315628435760038495915707758235004078258837389024124261735560004100679591906318506257400142206172954325190681814792847192856119258140772980193363283386441962041988871891225319584672260198913596266911873284127614232167301388894238055511066261585763754427108720961
e = 65537

# Get ALL PRIME FACTORS
f = FactorDB(n) # Initialise FactorDB class module
f.connect() # Connect to API
factors = f.get_factor_list() # Get all factors from FactorDB website
print(factors)

'''
Factors: 
[
  8673621841,
  9000257927,
  9005868947,
  ...
  16377562727,
  17083009547
]

Since there are multiple prime factors, 
this is multi-prime RSA

phi = ( factor[0]-1 )( factor[1]-1 )...( factor[n]-1 )
'''

# Finding phi
phi = 1
for f in factors:
    phi *= (f-1)

# Finding d
d = inverse(e, phi)

# Decrypting
m = pow(c, d, n)
m = long_to_bytes(m)
print(m)

# NYRCS{bradyn_multirsa_puzzle_12345}